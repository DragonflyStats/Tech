
Course Description
Software as a Service (SaaS)
Agile vs. Waterfall
Waterfall Method
Agile Method
The Verdict
Ruby on Rails
Complex Event Processing
Service-oriented architecture (SOA)

Course Description

This course teaches the engineering fundamentals for long-lived software using the highly-productive Agile development method for Software as a Service (SaaS) using Ruby on Rails. Agile developers continuously refine and refactor a working but incomplete prototype until the customer is happy with result, with the customer offering continuous feedback. 

Agile emphasizes user stories to validate customer requirements; test-driven development to reduce mistakes; biweekly iterations of new software releases; and velocity to measure progress. 

We will introduce all these elements of the Agile development cycle, and go through one iteration by adding features to a simple app and deploying it on the cloud using tools like Github, Cucumber, RSpec, SimpleCov, Pivotal Tracker, and Heroku.


Software as a Service (SaaS) 
Software as a Service (SaaS) is a software distribution model in which applications are hosted by a vendor or service provider and made available to customers over a network, typically the Internet.

SaaS is becoming an increasingly prevalent delivery model as underlying technologies that support Web services and service-oriented architecture (SOA) mature and new developmental approaches, such as Ajax, become popular. Meanwhile, broadband service has become increasingly available to support user access from more areas around the world.

SaaS is closely related to the ASP (application service provider) and on demand computing software delivery models. IDC identifies two slightly different delivery models for SaaS. The hosted application management (hosted AM) model is similar to ASP: a provider hosts commercially available software for customers and delivers it over the Web. In the software on demand model, the provider gives customers network-based access to a single copy of an application created specifically for SaaS distribution.

Benefits of the SaaS model include:
•easier administration
•automatic updates and patch management
•compatibility: All users will have the same version of software.
•easier collaboration, for the same reason
•global accessibility.

The traditional model of software distribution, in which software is purchased for and installed on personal computers, is sometimes referred to as software as a product.


Agile vs. Waterfall
Waterfall Method

The Waterfall model is a sequential design process used in software development, with the development life cycle of Conception, Initiation, Analysis, Design, Construction, Testing, Implementation, and Maintenance progressing steadily downwards, just like a waterfall flows down. Completion of one stage leads to another, and each stage has its separate goals. It owes its origin to the standard workflow process in the construction and manufacturing industries.
The advantage of the Waterfall method is the division of the project into tight compartments, reducing the dependency on individuals in the team. Key individuals coming and going at the transition points of stages does not affect project execution. The method also calls for robust documentation, further lessening the dependence on individuals.
The disadvantages are the inflexibility and rigidity. Just as water that flows down a waterfall cannot come back, it is not possible to alter a completed stage or even the project design in any way. Requirements gathering upfront therefore become critical. The logic is that the time spent upfront to ensure comprehensive requirements gathering and design saves considerable time and effort later.
Agile Method
Agile software development bases itself on an iterative and incremental approach. Software developers work on small modules, and respond to users' changed requirements rather than follow a specific or predetermined plan of action. The basic design is simple, and changes are made as work progresses.
Unlike with the Waterfall method, testing and customer feedback occurs simultaneously with development. This method gives priority to collaboration over design. Interactions among stakeholders take priority over processes and tools, and working software takes priority over documenting procedures. Different developers may work on different modules, and integrate all modules together at the end.

Agile methods of software development gained popularity in the 1990s as a reaction to the drawbacks of the traditional Waterfall methods. Critics considered the Waterfall method heavily regulated, regimented, and micromanaged to suit many needs, and have been working on various incremental approaches experimented since 1957.

The Verdict

Both the Waterfall method and the Agile method of software development have their uses. Although Agile arose as a reaction to the limitations imposed by the Waterfall method, Waterfall still retains its relevance as a better method when the environment is stable with no room for changes, when frequent interactions with ends users and other stakeholders are not possible, or when there is a risk of key developers quitting the project midway.

Agile is a lightweight method. As software developers focus on smaller work areas, overhead becomes less, and the project costs considerably less than when using the Waterfall method. When customer requirements are hazy, or the business environment is uncertain, Agile methods that allow making frequent changes, and testing during the construction stage remains the best choice. Successful execution of Agile projects nevertheless requires highly skilled and competent developers, and stakeholders who know what they want. With the scope to accommodate changes, an Agile project can easily lose its way.

Agile development is known for being cheaper, faster, and quicker to respond to changing market demands, as compared to the slower but steady, sequential process of the waterfall method. And while Agile may be more suitable for projects that are amenable to its speed and quick reaction time, traditional waterfall industries are starting to see the value of using this methodology.

Agile development centers around short “sprints” where developers race to fix bugs and write working software within a span of anywhere between 4 to 6 weeks. Agile is most often talked about in terms of modern Web 2.0 applications where we see frequent updates and changes to code as feature sets are enhanced and new functionality is added at a rapid pace. This methodology is typically seen as the opposite of the waterfall process where development and management follows a sequential process. In waterfall projects, progress is seen as cascading steadily through the phases of conception, initiation, analysis, design, development and testing.


Ruby on Rails
Ruby on Rails, often shortened to Rails or RoR, is an open source full-stack web application framework for the Ruby programming language. Ruby on Rails is not to be confused with Ruby, which is a general-purpose programming language that Ruby on Rails runs on. 

Ruby itself existed for more than 10 years before the first release of Ruby on Rails. Rails is a full-stack framework, meaning that it gives the Web developer the full ability to gather information from the web server, talking/querying the database, and template rendering out of the box. As a result, Rails features a routing system that is independent of the Web server.


Complex Event Processing

Complex event processing (CEP) is the use of technology to predict high-level events likely to result from specific sets of low-level factors. CEP identifies and analyzes cause-and-effect relationships among eventsin real time, allowing personnel to proactively take effective actions in response to specific scenarios.

CEP is an evolving paradigm originally conceived in the 1990s by Dr. David Luckham at Stanford University. CEP is used in security policy risk management, customer relationship management (CRM), application servers and middleware.

One important aspect of CEP is business activity monitoring (BAM), the use of technology to proactively define and analyze the most critical opportunities and risks in an enterprise. CEP is especially effectivein situations involving numerous factors that interact in variable ways, such as the investment and lending environments for financial institutions. CEP can also be used in threat management for communications networks.

Service-oriented architecture (SOA)
A service-oriented architecture (SOA) is the underlying structure supporting communications between services. SOA defines how two computing entities, such as programs, interact in such a way as to enable one entity toperform a unit of work on behalf of another entity. Service interactions are defined using a description language.
Each interaction is self-contained and loosely coupled, so that each interaction is independent of any other interaction. Simple Object Access Protocol (SOAP)-based Web services are becoming the most common implementation of SOA. However, there are non-Web services implementations of SOA that provide similar benefits.
The protocol independence of SOA means that different consumers can communicate with the service in different ways. Ideally, there should be a management layer between the providers and consumers to ensure complete flexibility regarding implementation protocols.


Duck typing

Duck typing is a style of dynamic typing in which an object's current set of methods and properties determines the valid semantics, rather than its inheritance from a particular class or implementation of a specific interface. 

The name of the concept refers to the duck test, attributed to James Whitcomb Riley, which may be phrased as follows:
When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.

In duck typing, one is concerned with just those aspects of an object that are used, rather than with the type of the object itself. For example, in a non-duck-typed language, one can create a function that takes an object of type Duck and calls that object's walk and quack methods. In a duck-typed language, the equivalent function would take an object of any type and call that object's walk and quack methods.

 If the object does not have the methods that are called then the function signals a run-time error. It is this action of any object having the correct walk and quack methods being accepted by the function that evokes the quotation and hence the name of this form of typing.

Duck typing is aided by habitually not testing for the type of arguments in method and function bodies, relying on documentation, clear code and testing to ensure correct use.

